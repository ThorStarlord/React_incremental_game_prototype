/**
 * @file copyUtils.ts
 * @description Utility functions for the Copy system.
 */

import { COPY_SYSTEM } from '../../../constants/gameConstants';
import type { Copy } from '../state/CopyTypes';
import type { Trait } from '../../Traits/state/TraitsTypes';
import type { NPC } from '../../NPCs/state/NPCTypes';

/** Clamp a number between min and max. */
export const clamp = (value: number, min: number, max: number): number => Math.min(max, Math.max(min, value));

/** Generate a unique Copy ID. (Simple timestamp-based; can swap for uuid later.) */
export const generateCopyId = (): string => `copy_${Date.now()}_${Math.floor(Math.random() * 1e6)}`;

/** Generate a display name for a copy derived from NPC name. */
export const generateCopyName = (npcName: string, sequence?: number): string => {
  return sequence ? `${npcName} Echo ${sequence}` : `Copy of ${npcName}`;
};

/** Return true if a Copy meets maturity & loyalty thresholds for essence bonus qualification. */
export const isQualifyingForEssenceBonus = (copy: Copy): boolean =>
  copy.maturity >= COPY_SYSTEM.MATURITY_THRESHOLD && copy.loyalty > COPY_SYSTEM.LOYALTY_THRESHOLD;

/** Produce a shallow copy of the Copy with maturity & loyalty clamped to bounds. */
export const normalizeCopyProgress = (copy: Copy): Copy => ({
  ...copy,
  maturity: clamp(copy.maturity, COPY_SYSTEM.MATURITY_MIN, COPY_SYSTEM.MATURITY_MAX),
  loyalty: clamp(copy.loyalty, COPY_SYSTEM.LOYALTY_MIN, COPY_SYSTEM.LOYALTY_MAX),
});

/** Apply maturity growth (respecting accelerated multiplier) and return clamped value. */
export const applyGrowth = (current: number, delta: number, accelerated: boolean): number => {
  const base = current + delta * (accelerated ? COPY_SYSTEM.ACCELERATED_GROWTH_MULTIPLIER : 1);
  return clamp(base, COPY_SYSTEM.MATURITY_MIN, COPY_SYSTEM.MATURITY_MAX);
};

/** Apply loyalty decay and return clamped value. */
export const applyLoyaltyDecay = (current: number, delta: number): number => {
  const value = current - delta;
  return clamp(value, COPY_SYSTEM.LOYALTY_MIN, COPY_SYSTEM.LOYALTY_MAX);
};

/** Given an NPC connectionDepth, return the max inherited trait count allowed. */
export const getInheritedTraitCap = (connectionDepth: number): number => {
  let cap = 0;
  for (const rule of COPY_SYSTEM.INHERITED_TRAIT_CAPS) {
    if (connectionDepth >= rule.depth) cap = rule.cap; else break;
  }
  return cap;
};

/**
 * Compute the list of inherited trait IDs for a new Copy based on NPC data.
 * - Takes at most cap traits from npc.availableTraits that are actually slotted in npc.sharedTraitSlots (if present).
 * - Falls back to npc.availableTraits order if sharedTraitSlots not present.
 */
export const computeInheritedTraits = (npc: NPC): string[] => {
  const cap = getInheritedTraitCap(npc.connectionDepth ?? 0);
  if (cap <= 0) return [];
  const shared = (npc.sharedTraitSlots ?? [])
    .map(s => s.traitId)
    .filter((id): id is string => !!id);
  if (shared.length > 0) {
    return shared.slice(0, cap);
  }
  const av = npc.availableTraits ?? [];
  return av.slice(0, cap);
};

/**
 * Calculate the Essence-per-second generated by a single Copy.
 * Formula: Base Copy Rate * Trait Multiplier * Loyalty Modifier
 * - Base Copy Rate: COPY_SYSTEM.BASE_ESSENCE_GENERATION
 * - Trait Multiplier: 1.0 + sum of all essenceGenerationMultiplier values found on the Copy's active traits
 * - Loyalty Modifier: 0.5 if loyalty < COPY_SYSTEM.LOYALTY_THRESHOLD, else 1.0
 */
export const calculateCopyEssenceGeneration = (
  copy: Copy,
  allTraits: Record<string, Trait>
): number => {
  // Must at least be mature to qualify; caller will additionally check maturity threshold.
  const base = COPY_SYSTEM.BASE_ESSENCE_GENERATION;

  // Collect active trait IDs (inherited + shared via slots)
  const sharedIds = (copy.traitSlots ?? [])
    .map(s => s.traitId)
    .filter((id): id is string => !!id);
  const activeIds = [...(copy.inheritedTraits ?? []), ...sharedIds];

  // Sum essenceGenerationMultiplier contributions.
  // Effects may be array or object; if object, read property essenceGenerationMultiplier.
  let additiveMultiplier = 0; // we'll add to 1.0 later
  for (const id of activeIds) {
    const trait = allTraits[id];
    if (!trait || !trait.effects) continue;
    const eff = trait.effects as any;
    if (Array.isArray(eff)) {
      for (const e of eff) {
        if (e && typeof e === 'object' && 'type' in e) {
          // Not a key-value map; skip unless a specific type is defined in the future
        }
      }
    } else if (typeof eff === 'object') {
      const val = Number(eff.essenceGenerationMultiplier ?? 0);
      if (!Number.isNaN(val)) additiveMultiplier += val;
    }
  }
  const traitMultiplier = 1 + additiveMultiplier;

  // Loyalty modifier
  const loyaltyModifier = copy.loyalty < COPY_SYSTEM.LOYALTY_THRESHOLD ? 0.5 : 1.0;

  return base * traitMultiplier * loyaltyModifier;
};
