/**
 * @file copyUtils.ts
 * @description Utility functions for the Copy system.
 */

import { COPY_SYSTEM } from '../../../constants/gameConstants';
import type { Copy } from '../state/CopyTypes';
import type { Trait, TraitEffect, TraitEffectValues } from '../../Traits/state/TraitsTypes';
import type { NPC } from '../../NPCs/state/NPCTypes';

/** Clamp a number between min and max. */
export const clamp = (value: number, min: number, max: number): number => Math.min(max, Math.max(min, value));

/** Generate a unique Copy ID. (Simple timestamp-based; can swap for uuid later.) */
export const generateCopyId = (): string => `copy_${Date.now()}_${Math.floor(Math.random() * 1e6)}`;

/** Generate a display name for a copy derived from NPC name. */
export const generateCopyName = (npcName: string, sequence?: number): string => {
  return sequence ? `${npcName} Echo ${sequence}` : `Copy of ${npcName}`;
};

/** Return true if a Copy meets maturity & loyalty thresholds for essence bonus qualification. */
export const isQualifyingForEssenceBonus = (copy: Copy): boolean =>
  copy.maturity >= COPY_SYSTEM.MATURITY_THRESHOLD && copy.loyalty > COPY_SYSTEM.LOYALTY_THRESHOLD;

/** Produce a shallow copy of the Copy with maturity & loyalty clamped to bounds. */
export const normalizeCopyProgress = (copy: Copy): Copy => ({
  ...copy,
  maturity: clamp(copy.maturity, COPY_SYSTEM.MATURITY_MIN, COPY_SYSTEM.MATURITY_MAX),
  loyalty: clamp(copy.loyalty, COPY_SYSTEM.LOYALTY_MIN, COPY_SYSTEM.LOYALTY_MAX),
});

/** Apply maturity growth (respecting accelerated multiplier) and return clamped value. */
export const applyGrowth = (current: number, delta: number, accelerated: boolean): number => {
  const base = current + delta * (accelerated ? COPY_SYSTEM.ACCELERATED_GROWTH_MULTIPLIER : 1);
  return clamp(base, COPY_SYSTEM.MATURITY_MIN, COPY_SYSTEM.MATURITY_MAX);
};

/** Apply loyalty decay and return clamped value. */
export const applyLoyaltyDecay = (current: number, delta: number): number => {
  const value = current - delta;
  return clamp(value, COPY_SYSTEM.LOYALTY_MIN, COPY_SYSTEM.LOYALTY_MAX);
};

/** Given an NPC connectionDepth, return the max inherited trait count allowed. */
export const getInheritedTraitCap = (connectionDepth: number): number => {
  let cap = 0;
  for (const rule of COPY_SYSTEM.INHERITED_TRAIT_CAPS) {
    if (connectionDepth >= rule.depth) cap = rule.cap; else break;
  }
  return cap;
};

/**
 * Compute the list of inherited trait IDs for a new Copy based on NPC data.
 * - Takes at most cap traits from npc.availableTraits that are actually slotted in npc.sharedTraitSlots (if present).
 * - Falls back to npc.availableTraits order if sharedTraitSlots not present.
 */
export const computeInheritedTraits = (npc: NPC): string[] => {
  const cap = getInheritedTraitCap(npc.connectionDepth ?? 0);
  if (cap <= 0) return [];
  const shared = (npc.sharedTraitSlots ?? [])
    .map(s => s.traitId)
    .filter((id): id is string => !!id);
  if (shared.length > 0) {
    return shared.slice(0, cap);
  }
  const av = npc.availableTraits ?? [];
  return av.slice(0, cap);
};

/**
 * Calculate the Essence-per-second generated by a single Copy.
 * Formula: Base Copy Rate * Trait Multiplier * Loyalty Modifier
 * - Base Copy Rate: COPY_SYSTEM.BASE_ESSENCE_GENERATION
 * - Trait Multiplier: 1.0 + sum of all essenceGenerationMultiplier values found on the Copy's active traits
 * - Loyalty Modifier: 0.5 if loyalty < COPY_SYSTEM.LOYALTY_THRESHOLD, else 1.0
 */
export const calculateCopyEssenceGeneration = (
  copy: Copy,
  allTraits: Record<string, Trait>
): number => {
  // Must at least be mature to qualify; caller will additionally check maturity threshold.
  const base = COPY_SYSTEM.BASE_ESSENCE_GENERATION;

  // Collect active trait IDs (inherited + shared via slots)
  const sharedIds = (copy.traitSlots ?? [])
    .map(s => s.traitId)
    .filter((id): id is string => !!id);
  const activeIds = [...(copy.inheritedTraits ?? []), ...sharedIds];

  // Sum essenceGenerationMultiplier contributions using helper.
  let additiveMultiplier = 0; // we'll add to 1.0 later
  for (const id of activeIds) {
    const trait = allTraits[id];
    if (!trait || !trait.effects) continue;
    additiveMultiplier += getEssenceGenerationMultiplierFromEffects(trait.effects);
  }
  const traitMultiplier = 1 + additiveMultiplier;

  // Loyalty modifier
  const loyaltyModifier = copy.loyalty < COPY_SYSTEM.LOYALTY_THRESHOLD ? 0.5 : 1.0;

  return base * traitMultiplier * loyaltyModifier;
};

/** Type guard: effects object is a key-value map (TraitEffectValues), not an array. */
const isTraitEffectValues = (effects: Trait['effects']): effects is TraitEffectValues =>
  !!effects && typeof effects === 'object' && !Array.isArray(effects);

/** Narrower helper to detect an arbitrary object with an essenceGenerationMultiplier number. */
const hasEssenceGenMultiplier = (obj: unknown): obj is { essenceGenerationMultiplier: number } =>
  !!obj && typeof obj === 'object' && 'essenceGenerationMultiplier' in (obj as Record<string, unknown>)
  && typeof (obj as { essenceGenerationMultiplier: unknown }).essenceGenerationMultiplier === 'number';

/**
 * Helper: Sum all essenceGenerationMultiplier contributions from a trait's effects.
 * - If effects is a key-value map, reads effects.essenceGenerationMultiplier if present.
 * - If it's an array, future-proof by scanning entries for an essenceGenerationMultiplier number.
 */
export const getEssenceGenerationMultiplierFromEffects = (effects: TraitEffect[] | TraitEffectValues): number => {
  if (!effects) return 0;
  if (isTraitEffectValues(effects)) {
    const val = Number((effects as TraitEffectValues).essenceGenerationMultiplier ?? 0);
    return Number.isNaN(val) ? 0 : val;
  }
  // effects is TraitEffect[] (or array-like). Officially TraitEffect doesn't include the multiplier,
  // but we defensively scan objects that may carry it in the future.
  let sum = 0;
  if (Array.isArray(effects)) {
    for (const e of effects) {
      if (hasEssenceGenMultiplier(e)) {
        const v = Number(e.essenceGenerationMultiplier);
        if (!Number.isNaN(v)) sum += v;
      }
    }
  }
  return sum;
};
