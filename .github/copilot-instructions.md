# React Project Best Practices: Incremental RPG Prototype

This document outlines best practices and conventions to follow while developing the React Incremental RPG Prototype. Adhering to these guidelines will help maintain code quality, consistency, and ease of collaboration.

## 1. Project Structure and Organization

*   **Feature-Sliced Structure:** Continue using the feature-sliced approach (`src/features/FeatureName/`). This promotes modularity and scalability.
    *   **Convention:** Feature directories should be **singular and `PascalCase`** (e.g., `src/features/Player`, `src/features/Trait`, `src/features/Copy`). The corresponding Redux slice key should be **singular and `camelCase`** (e.g., `player`, `trait`, `copy`).
*   **Inside Features:** Maintain a consistent internal structure within each feature folder:
    *   `components/`: Contains UI components specific to the feature.
        *   `containers/`: Smart components connected to Redux or managing complex logic.
        *   `ui/`: Dumb/Presentational components receiving props.
        *   `layout/`: Components specifically for structuring the feature's UI parts.
    *   `state/`: Redux Toolkit slice, types, selectors, and thunks for the feature.
    *   `hooks/`: Custom React hooks specific to the feature.
    *   `utils/`: Utility functions specific to the feature.
    *   `index.ts`: Barrel file exporting the public API of the feature (key components, actions, selectors).
*   **Shared Components/Utils:** Use `src/shared/` for components, hooks, and utils reusable across multiple features.
*   **Layout:** Keep global layout components in `src/layout/`.
*   **Pages:** Use `src/pages/` for top-level page components that assemble features and layouts for specific routes.
*   **Constants:** Store game-wide constants in `src/constants/` (e.g., `gameConstants.ts`, `relationshipConstants.ts`). Avoid magic numbers/strings.
*   **Types:** Define shared types or global types if necessary, but prefer co-locating types with their features (`FeatureTypes.ts`) or within the files they are used if very specific. The `src/css.d.ts` for CSS Modules is correct.
*   **Routing:** Centralize route definitions in `src/routes/AppRouter.tsx`. Use layout routes (`src/routes/components/Layouts.tsx`) for shared page structures.

## 2. Component Design

*   **Functional Components & Hooks:** Exclusively use functional components with React Hooks.
*   **Separation of Concerns:**
    *   Strive for a clear separation between components handling logic/state (containers) and components focused on rendering UI (presentational/ui).
    *   Extract complex logic into custom hooks (`src/features/FeatureName/hooks/` or `src/hooks/` for shared hooks).
*   **Props:** Use clear and specific `interface` definitions for component props. Avoid overly generic prop names. Use destructuring in function signatures.
*   **Keep Components Small:** Break down complex components into smaller, reusable ones.
*   **MUI Usage:** Leverage Material UI components for building the UI consistently. Use the `sx` prop for one-off styles and `styled()` or CSS Modules for more complex/reusable component styling.
*   **Keys:** Always provide stable and unique `key` props when rendering lists of components. Avoid using array indices as keys if the list can change order.

## 3. State Management (Redux Toolkit)

*   **Embrace RTK:** Fully utilize Redux Toolkit features (`createSlice`, `createAsyncThunk`, `createSelector`).
*   **Slices:** Keep slices focused on a specific domain/feature (e.g., `PlayerSlice`, `TraitsSlice`, `EssenceSlice`).
*   **Immutability:** Leverage Immer (built into `createSlice`) for writing immutable updates easily within reducers. Do *not* mutate state directly outside of the Immer proxy.
*   **Reducers:** Keep reducers pure – they should only depend on `state` and `action` and produce a new state without side effects.
*   **Actions:** Use the action creators generated by `createSlice`. Define clear payload interfaces (`FeatureTypes.ts`).
*   **Selectors:**
    *   Define selectors alongside slices (`FeatureSelectors.ts`).
    *   Use `createSelector` from Reselect (re-exported by RTK) for memoized selectors, especially for derived or computed data, to optimize performance.
    *   Use the typed hooks (`useAppDispatch`, `useAppSelector` from `src/app/hooks.ts`) throughout the application.
*   **Thunks:** Use `createAsyncThunk` for asynchronous logic (like fetching initial data, complex multi-step actions like saving/loading that involve reading state). Keep API/async logic out of components.
*   **State Normalization:** For data like traits or items, consider storing them in a normalized structure (e.g., `entities: { [id: string]: Item }`, `ids: string[]`) within the slice for easier lookup and updates, although `Record<string, Trait>` is often sufficient for many cases.

## 4. TypeScript Usage

*   **Strong Typing:** Type everything possible – props, state, function arguments/return values, Redux actions/state.
*   **Interfaces/Types:** Define clear `interface` or `type` aliases for data structures (`PlayerState`, `Trait`, `EssenceState`, etc.). Co-locate these within the feature's `state` directory or directly in files if highly localized.
*   **Utility Types:** Use TypeScript utility types (`Partial`, `Readonly`, `Record`, `Omit`, etc.) where appropriate.
*   **Avoid `any`:** Use `unknown` or specific types instead of `any` whenever possible. Use `any` only as a last resort or for temporary workarounds.
*   **Strict Mode:** Keep `strict: true` enabled in `tsconfig.json` (as you have it) and address any resulting errors.
*   **Non-Null Assertion (`!`):** Avoid using the non-null assertion operator (`!`) unless you are *absolutely certain* a value cannot be `null` or `undefined`. Prefer explicit checks or optional chaining (`?.`).

## 5. Styling (MUI & CSS Modules)

*   **Consistency:** Choose a primary styling approach and stick to it where possible. You're using MUI and CSS Modules.
    *   **MUI:** Use the `sx` prop for minor, component-specific overrides. Use `styled()` for creating reusable styled components based on MUI primitives.
    *   **CSS Modules:** Use `.module.css` files for component-specific styles that don't fit well with MUI's system or require complex selectors/animations. Ensure class names are descriptive (`styles.traitCardHeader`).
*   **Theme:** Leverage the MUI theme (`src/theme/provider.tsx`, `src/theme.ts`). Define custom theme tokens (colors, spacing, typography) in `src/theme.ts` or `src/theme/defaults.ts` and use them within components via `useTheme` or the `sx` prop's theme access. Your `ThemeContext` setup seems appropriate.
*   **Global Styles:** Use `src/index.css` or MUI's `CssBaseline` for minimal global resets and base styles (like body font). Avoid overly broad global selectors.

## 6. Routing (React Router)

*   **Centralized Routes:** Define all application routes in `src/routes/AppRouter.tsx`.
*   **Layout Routes:** Use `Outlet` and wrapper components (`src/routes/components/Layouts.tsx`) for shared layouts (e.g., `GameLayout`).
*   **Programmatic Navigation:** Use the `useNavigate` hook for navigation triggered by actions (e.g., after loading a game).
*   **Route Parameters:** Use `useParams` hook to access URL parameters.
*   **Not Found:** Implement a 404 page or redirect for undefined routes.

## 7. Asynchronous Operations & Side Effects

*   **Redux Thunks:** Handle async logic like loading initial data (`fetchTraitsThunk`), saving/loading (`saveGameThunk`, `loadGameThunk`), or complex multi-step actions (`makeTraitPermanentThunk`) using `createAsyncThunk`.
*   **`useEffect`:** Use `useEffect` for component lifecycle events, subscriptions, or interactions with browser APIs. Remember the dependency array to control when the effect runs. Provide cleanup functions for subscriptions or timers.
*   **Loading/Error States:** Manage loading and error states related to async operations within your Redux slices (e.g., `loading: boolean`, `error: string | null` in `TraitsState`). Update these states in the `extraReducers` for thunks. Display feedback (spinners, error messages) in components based on these states.

## 8. Performance Optimization

*   **Memoization:**
    *   Use `React.memo` for functional components that might re-render unnecessarily with the same props.
    *   Use `useMemo` to memoize expensive calculations within components.
    *   Use `useCallback` to memoize functions passed down as props, especially event handlers, to prevent unnecessary re-renders of child components relying on referential equality.
*   **Redux Selectors:** Use `createSelector` to memoize Redux selector computations.
*   **Code Splitting:** React Router and CRA/Vite handle basic route-based code splitting. Consider `React.lazy` and `Suspense` for more granular component-level splitting if needed later.
*   **Bundle Size:** Periodically analyze your bundle size (`source-map-explorer` or similar tools) to identify large dependencies or chunks.
*   **Virtualization:** For potentially very long lists (e.g., extensive trait codex, inventory), consider using libraries like `react-window` or `react-virtualized` later if performance becomes an issue.

## 9. Error Handling

*   **Error Boundaries:** Use React Error Boundaries (class components or libraries like `react-error-boundary`) to catch rendering errors in specific parts of the UI and display fallback UI (like your `TraitSystemErrorBoundary`).
*   **Async Errors:** Handle errors in Promises and async thunks (`try/catch`, `.catch()`, `rejectWithValue` in thunks). Update state to reflect errors and show appropriate messages to the user.
*   **Input Validation:** Validate user input (e.g., import codes, settings values) to prevent errors.

## 10. Testing

*   **Setup:** Your `src/tests/setupTests.ts` with `@testing-library/jest-dom` is a good start.
*   **Unit Tests:** Write unit tests for utility functions (`utils/`), Redux reducers, and complex logic within hooks using Jest.
*   **Integration/Component Tests:** Use React Testing Library (`@testing-library/react`) to test components, interactions, and state integration. Focus on testing component behavior from the user's perspective.
*   **Coverage:** Aim for reasonable test coverage, especially for critical game logic, state management, and utility functions.

## 11. Code Style and Linting

*   **ESLint & Prettier:** Configure and use ESLint and Prettier to enforce consistent code style and catch potential errors. Integrate them into your editor and CI pipeline. Your `package.json` suggests these are likely set up via `react-scripts`.
*   **Naming Conventions:** Follow consistent naming conventions (e.g., `camelCase` for variables/functions, `PascalCase` for components/types/interfaces).
*   **File Naming:** Use `PascalCase` for component files (`TraitPanel.tsx`) and `camelCase` for non-component files (`traitUtils.ts`).

## 12. Documentation and Comments

*   **README:** Keep `README.md` updated with setup, build, and run instructions.
*   **JSDoc:** Use JSDoc comments (`/** ... */`) for functions, components, types, and complex logic sections to explain their purpose, parameters, and return values.
*   **Feature Docs:** Utilize the `docs/` folder for higher-level documentation on systems like NPC interaction or specific features (as you've started).
*   **Inline Comments:** Use inline comments (`//`) sparingly for clarifying non-obvious code sections. Avoid commenting *what* the code does; comment *why* it does it, if necessary.

## 13. Accessibility (a11y)

*   **Semantic HTML:** Use appropriate HTML elements (MUI helps with this).
*   **ARIA Attributes:** Add ARIA attributes where necessary for interactive elements that lack clear semantics.
*   **Keyboard Navigation:** Ensure the application is navigable and usable via keyboard.
*   **Color Contrast:** Check for sufficient color contrast, especially when customizing themes.

## 14. Security Considerations (Client-Side)

*   **Input Sanitization/Validation:** While less critical for a local prototype, be mindful of validating any user input (like import codes) if implemented.
*   **Cross-Site Scripting (XSS):** React and MUI generally protect against XSS when used correctly (don't use `dangerouslySetInnerHTML` without sanitization).
*   **Local Storage:** Be aware that data in `localStorage` is not secure. Don't store sensitive information.

## 15. Dependency Management

*   **Updates:** Regularly review and update dependencies (`npm update` or `yarn upgrade`) to get bug fixes and security patches. Test thoroughly after updates.
*   **Bundle Size:** Be mindful of adding large dependencies. Analyze their impact on the final bundle size.
*   **Cleanup:** Remove unused dependencies.

---

By following these guidelines, you'll build a more robust, maintainable, and scalable React application. Remember that these are guidelines, not strict rules; adapt them as needed for your specific project context.